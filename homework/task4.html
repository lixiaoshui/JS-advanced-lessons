<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>task4</title>
</head>
<body>
    
</body>
<script>
    function Foo(userName,age){
        this.userName = userName;
        this.age = age;
    }
    Foo.prototype.sayHello = function(){
        console.log(this.userName + "say hello");
    }
    var f1 = new Foo("zhangsan",20);
    console.log(f1.__proto__ == Foo.prototype);
    f1.sayHello();
    /*
        关系一：f1对象的__proto__属性预期构造函数Foo的prototype属性，指向相同，所以通过Foo实例化得到的对象可以去Foo.prototype上查找方法。例如sayHello方法
    */
    console.log(Foo.prototype.__proto__ == Object.prototype);
    /*
        关系二：Foo.prototype是f1的原型对象，同时也是实例对象，任何对象都可以看做是通过Object构造函数的new操作实例化的对象，因此Foo.prototype作为实例对象，构造函数是Object。
        原型对象是Object.prototype，函数Object的prototype属性指向原型对象Object.prototype实例对象。
        Foo.prototype的proto属性也指向原型对象Object.prototype
    */
    console.log(Object.prototype.__proto__ == null);
    /*
        关系三：__proto__属性是一个对象指向它的父对象，当访问一个对象的属性时，若找不到，则去寻找__proto__指向的对象。如果还找不到，则继续向上寻找，直到原型链的顶端null
    */
    Foo.prototype.sayBye = function(){
        console.log(this.userName + "say Bye");
    }
    f1.sayBye();
    /*
        关系四：构造函数有一个prototype属性，指向实例对象的原型对象，而构造函数Foo()的原型对象就是Foo.prototype
    */
    console.log(Foo.prototype.constructor == Foo);
    /*
        关系五：Foo.prototype是f1的原型对象，原型对象有constructor属性，指向该原型对象的构造函数。
        构造函数Foo()的原型对象就是Foo.prototype
    */
    console.log(Foo.__proto__ == Function.prototype);
    /*
        关系六：函数可以看做是具有特殊功能的对象，且任何函数可以看做是由Function构造函数的new操作实例化的结果。
        把Foo()当做实例对象，其构造函数就是Function()，其原型对象是Function.prototype.所以函数Foo的proto属性指向Function.prototype,函数Function()的prototype属性也指向Function.prototype。
    */
    console.log(Function.prototype.__proto__ === Object.prototype);
    /*
        关系七：Function.prototype当做实例对象，并且所有对象都能看做是Object构造函数的new操作实例化的对象，所以Function.prototype作为实例对象，他的__proto__属性指向Object.prototype
    */
    var obj1 = new Object();
    console.log(obj1.__proto__ == Object.prototype);
    /*
        关系八：obj1对象的__proto__属性与Object的prototype属性指向相同，所以通过Object实例化得到的对象可以在Object.prototype上寻找到
    */
    /*
        关系九：构造函数的prototype属性指向实例对象的原型对象，构造函数Object的原型对象即为Object.prototype
    */
    console.log(Object.prototype.constructor == Object);
    /*
        关系十：原型对象有constructor属性，指向该原型对象的构造函数，而Object.prototype的构造函数即Object
    */
    console.log(Object.__proto__ == Function.prototype);
    /*
        关系十一：把Object当做一个实例对象，他的构造函数是Function，他的原型对象是Function.prototype
        __proto__属性就是指向一个实例对象的原型对象
    */
    /*
        关系十二：构造函数的prototype属性指向实例对象的原型对象，构造函数Function的原型对象就是Function.prototype
    */
    console.log(Function.prototype.constructor == Function);
    /*
        关系十三：每个原型对象都有constructor属性，指向该原型对象的构造函数，Function.prototype的构造函数是Function
    */
    console.log(Function.__proto__ == Function.prototype);
    /*
        关系十四：所有的函数都能看成是构造函数Function的new操作的实例化对象，Function作为实例对象，他的原型对象是Function.prototype
    */
</script>
</html>